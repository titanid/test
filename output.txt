----- START CODE: str158_dvumer_med_filtr_stab_to4ki.m -----
% Загрузка изображения
img = imread('tomo.jpg');

% Преобразование изображения в оттенки серого и тип double
grayImg = im2double(img);

% Медианная фильтрация с ядром 3х3
medianImg = medfilt2(grayImg, [3 3]);

% Вычисление градиентов изображения
[dx, dy] = gradient(medianImg);

% Вычисление градиентов градиентов
ddx = gradient(dx);
ddy = gradient(dy);
dxy = 0.5*(gradient(dx(:,1))+gradient(dy(1,:)));

% Вычисление стабильных точек методом Харриса
stablePoints = (dx.*ddy - dy.*dxy) ./ ((dx.^2 + dy.^2).^(3/2));

% Нахождение максимального значения стабильных точек
maxVal = max(max(stablePoints));

% Нормализация значений стабильных точек от 0 до 1
normalizedStablePoints = stablePoints ./ maxVal;

% Создание окна вывода с двумя подграфиками
figure;
subplot(1,2,1);
imshow(img);
title('Исходное изображение');

subplot(1,2,2);
imshow(normalizedStablePoints);
title('Стабильные точки');

% Сохранение выходных данных в отдельной переменной
outputImg = normalizedStablePoints;





----- END CODE: str158_dvumer_med_filtr_stab_to4ki.m -----

----- START CODE: str186_vidil_gran_obect.m -----
% Загрузка изображения
img = imread('tomo.jpg');

% Приведение к двумерному формату (если изображение цветное)
if size(img, 3) == 3
    img = rgb2gray(img);
end

% Медианная фильтрация для удаления шумов
med_img = img;

% Выделение границ
edge_img = edge(med_img, 'Canny');
% Показ изображения после выделения границ
figure; imshow(edge_img); title('Изображение после выделения границ');

% Выделение объектов
obj_img = imfill(edge_img, 'holes');
% Показ изображения после выделения объектов
figure; imshow(obj_img); title('Изображение после выделения объектов');

% Приведение к формату входного изображения (если изображение цветное)
if size(img, 3) == 3
    output_img = uint8(repmat(obj_img, [1 1 3])) * 255;
else
    output_img = uint8(obj_img) * 255;
end

% Показ исходного изображения
figure; imshow(img); title('Исходное изображение');
% Показ выходного изображения
figure; imshow(output_img); title('Выходное изображение');

% Сравнение исходного и выходного изображений
diff_img = imabsdiff(img, output_img);
figure; imshow(diff_img); title('Разница между исходным и выходным изображениями');

----- END CODE: str186_vidil_gran_obect.m -----

----- START CODE: str189.m -----


% Загрузка изображения
imya_fayla = 'tomo.jpg'; % Замените 'imya_kartinki.jpg' на имя файла с вашей картинкой
kartinka = imread(imya_fayla);
kartinka_gray = kartinka;

% Вычисление корреляционной функции
korrelatsionnaya_funktsiya = xcorr2(double(kartinka_gray));


% Вычисление спектра
spetr = fftshift(fft2(korrelatsionnaya_funktsiya));

% Усреднение локальных спектров
razmer_okna = 36; % Размер окна для усреднения
usredneniye_lokalnykh_spektr = filter2(ones(razmer_okna)/razmer_okna^2, abs(spetr));

% Маскирование анализируемого процесса гладкой функцией
maska = fspecial('gaussian', razmer_okna, 2); % Гауссовская маска с заданным размером и среднеквадратическим отклонением 2
maskirovaniye = filter2(maska, usredneniye_lokalnykh_spektr);

% Прямое сглаживание спектра
sglazhivaniye_spektra = filter2(ones(razmer_okna)/razmer_okna^2, abs(spetr));

% Сохранение результатов
rezultaty.korrelatsionnaya_funktsiya = korrelatsionnaya_funktsiya;
rezultaty.spetr = spetr;
rezultaty.usredneniye_lokalnykh_spektr = usredneniye_lokalnykh_spektr;
rezultaty.maskirovaniye = maskirovaniye;
rezultaty.sglazhivaniye_spektra = sglazhivaniye_spektra;

% Графики
figure;

% Входные данные
subplot(2, 3, 1);
imshow(kartinka_gray);
title('Входное изображение');

% Корреляционная функция
subplot(2, 3, 2);
imshow(korrelatsionnaya_funktsiya);
title('Корреляционная функция');

% Спектр
subplot(2, 3, 3);
imshow(log(abs(spetr)), []);
title('Спектр');

% Усредненный локальный спектр
subplot(2, 3, 4);
imshow(log(usredneniye_lokalnykh_spektr), []);
title('Усредненный локальный спектр');

% Маскированный спектр
subplot(2, 3, 5);
imshow(log(maskirovaniye), []);
title('Маскированный спектр');

% Сглаженный спектр
subplot(2, 3, 6);
imshow(log(sglazhivaniye_spektra), []);
title('Сглаженный спектр');

% Сравнение входного изображения и восстановленного
figure;
subplot(1, 2, 1);
imshow(kartinka_gray);
title('Входное изображение');
subplot(1, 2, 2);
vosstanovlennoye = ifft2(ifftshift(sglazhivaniye_spektra));
imshow(uint8(abs(vosstanovlennoye)));
title('Восстановленное изображение');



----- END CODE: str189.m -----

----- START CODE: str192.m -----
% Цифровая обработка изображений 
% Ускоренный алгоритм свертки сигналов 


% Загрузка изображения
im_path = 'tomo.jpg';
vkhodnaja_kartinka = imread(im_path);
figure; imshow(vkhodnaja_kartinka); title('Входное изображение');

% Преобразование изображения в оттенки серого
seroe_izobrazhenie = vkhodnaja_kartinka;
figure; imshow(seroe_izobrazhenie); title('Изображение в оттенках серого');

% Создание ядра свертки
razmer_jadra = 3; % Размер ядра свертки
jadro_svertki = (1/(razmer_jadra^2)) * ones(razmer_jadra, razmer_jadra);

% Функция свертки с использованием анонимных функций
seroe_izobrazhenie_double = im2double(seroe_izobrazhenie);
jadro_svertki_double = double(jadro_svertki);
usilennoe_izobrazhenie_double = nlfilter(seroe_izobrazhenie_double, [razmer_jadra razmer_jadra], @(b) sum(sum(b.*jadro_svertki_double)));
usilennoe_izobrazhenie = im2uint8(usilennoe_izobrazhenie_double);


% Сохранение усиленного изображения
usilennoe_izobrazhenie = uint8(usilennoe_izobrazhenie);
figure;
imshow(usilennoe_izobrazhenie); title('Усиленное изображение после свертки');

% Сравнение входного и выходного изображения
figure;
subplot(1,2,1); imshow(seroe_izobrazhenie); title('Исходное изображение в оттенках серого');
subplot(1,2,2); imshow(usilennoe_izobrazhenie); title('Усиленное изображение после свертки');

% Расчет среднеквадратичной ошибки (MSE) и сигнал/шум (PSNR)
mse = immse(seroe_izobrazhenie, usilennoe_izobrazhenie);
psnr = 10 * log10(255^2 / mse);

% Вывод среднеквадратичной ошибки (MSE) и сигнал/шум (PSNR)
fprintf('Среднеквадратичная ошибка (MSE): %0.4f\n', mse);
fprintf('Соотношение сигнал/шум (PSNR): %0.4f dB\n', psnr);

% Создание графика разности между исходным и усиленным изображениями
raznost_izobrazhenij = double(seroe_izobrazhenie) - double(usilennoe_izobrazhenie);
figure; imshow(mat2gray(abs(raznost_izobrazhenij))); title('Разность между исходным и усиленным изображениями');

% Гистограмма разности между исходным и усиленным изображениями
figure; histogram(raznost_izobrazhenij, 'Normalization', 'pdf');
title('Гистограмма разности между исходным и усиленным изображениями');
xlabel('Значение разности');
ylabel('Вероятность');

% Гистограмма исходного и усиленного изображения
figure;
subplot(1,2,1); imhist(seroe_izobrazhenie); title('Гистограмма исходного изображения');
subplot(1,2,2); imhist(usilennoe_izobrazhenie); title('Гистограмма усиленного изображения');

----- END CODE: str192.m -----

----- START CODE: str195.m -----


% Загрузка изображения
imya_fayla = 'tomo.jpg'; % Замените на имя вашего файла
vhodnaya_kartinka = imread(imya_fayla);
vhodnaya_kartinka_gray = vhodnaya_kartinka;

% Вычисление гистограммы входного изображения
[chastota_yarkosti, uroven_yarkosti] = imhist(vhodnaya_kartinka_gray);

% Гистограммное выравнивание
vyrovnenie_gistogrammy = histeq(vhodnaya_kartinka_gray);

% Вычисление гистограммы выходного изображения
[chastota_yarkosti_vykh, uroven_yarkosti_vykh] = imhist(vyrovnenie_gistogrammy);

% Сохранение обработанного изображения
vykhodnaya_kartinka = vyrovnenie_gistogrammy;
imwrite(vykhodnaya_kartinka, 'обработанная_картинка.jpg');

% Отображение входного и выходного изображения
figure;
subplot(2, 2, 1);
imshow(vhodnaya_kartinka);
title('Входное изображение');
subplot(2, 2, 2);
imshow(vykhodnaya_kartinka);
title('Выходное изображение');

% Отображение гистограмм входного и выходного изображения
subplot(2, 2, 3);
bar(uroven_yarkosti, chastota_yarkosti);
xlabel('Уровень яркости');
ylabel('Частота');
title('Гистограмма входного изображения');

subplot(2, 2, 4);
bar(uroven_yarkosti_vykh, chastota_yarkosti_vykh);
xlabel('Уровень яркости');
ylabel('Частота');
title('Гистограмма выходного изображения');

----- END CODE: str195.m -----

----- START CODE: str232.m -----

put_k_izobrazheniyu = 'tomo.jpg'; % Замените 'image.jpg' на имя вашего файла
izobrazhenie = imread(put_k_izobrazheniyu);

% Конвертация изображения в оттенки серого
izobrazhenie_serye_tona = izobrazhenie;

% Размер изображения
[visota, shirina] = size(izobrazhenie_serye_tona);

% Применение градиентного оператора Собеля по горизонтали и вертикали
sobel_gorizontal = fspecial('sobel');
sobel_vertikal = sobel_gorizontal';

% Вычисление градиентов по осям X и Y
grad_x = imfilter(double(izobrazhenie_serye_tona), sobel_gorizontal);
grad_y = imfilter(double(izobrazhenie_serye_tona), sobel_vertikal);

% Вычисление амплитуды градиента
amplituda_gradienta = sqrt(grad_x.^2 + grad_y.^2);

% Нормализация амплитуды градиента
norm_amplituda_gradienta = amplituda_gradienta / max(amplituda_gradienta(:));

% Бинаризация изображения с пороговым значением
porog = 0.1;
binarnoe_izobrazhenie = imbinarize(norm_amplituda_gradienta, porog);

% Сохранение выходных данных
kontury_izobrazheniya = binarnoe_izobrazhenie;

% Отображение графиков
figure;
subplot(2, 2, 1);
imshow(izobrazhenie);
title('Оригинальное изображение');
subplot(2, 2, 2);
imshow(izobrazhenie_serye_tona);
title('Изображение в оттенках серого');
subplot(2, 2, 3);
imshow(norm_amplituda_gradienta);
title('Нормализованная амплитуда градиента');
subplot(2, 2, 4);
imshow(kontury_izobrazheniya);
title('Градиентное выделение контуров');

----- END CODE: str232.m -----

----- START CODE: str289.m -----


% Загрузка изображения
img = imread('tomo.jpg');

% Преобразование изображения в градации серого
gray_img = img;

% Определение порогового значения для бинаризации изображения
threshold = graythresh(gray_img);

% Бинаризация изображения с использованием порогового значения
binary_img = imbinarize(gray_img, threshold);

% Выделение объектов на изображении
labeled_img = bwlabel(binary_img);

% Определение координат центра масс каждого объекта на изображении
stats = regionprops(labeled_img, 'Centroid');
centroids = cat(1, stats.Centroid);

% Визуализация изображения с выделенными объектами и их центрами
figure;
imshow(img);
hold on;
plot(centroids(:,1), centroids(:,2), 'r*');
title('Выделенные объекты и их центры на исходном изображении');

% Определение размера каждого объекта на изображении
sizes = regionprops(labeled_img, 'Area');
areas = cat(1, sizes.Area);

% Визуализация гистограммы размеров объектов
figure;
histogram(areas, 'BinWidth', 50);
title('Гистограмма размеров объектов');

% Определение фрагментов изображения для оптимальной фильтрации
fragment_size = 50;
fragments = im2col(binary_img, [fragment_size fragment_size], 'distinct');

% Применение оптимальной фильтрации к каждому фрагменту
filtered_fragments = arrayfun(@(x)optimal_filter(fragments(:,x)), 1:size(fragments,2), 'UniformOutput', false);
filtered_fragments = cat(2, filtered_fragments{:});

% Объединение фрагментов после фильтрации
filtered_img = col2im(filtered_fragments, [fragment_size fragment_size], size(binary_img), 'distinct');

% Визуализация исходного и отфильтрованного изображений
figure;
subplot(1,2,1);
imshow(binary_img);
title('Исходное бинарное изображение');
subplot(1,2,2);
imshow(filtered_img);
title('Отфильтрованное бинарное изображение');

% Сохранение выходных данных
output_data = struct('centroids', centroids, 'areas', areas, 'filtered_img', filtered_img);

% Определение оптимального фильтра для каждого фрагмента
function [filtered_fragment] = optimal_filter(fragment)
fragment_size = size(fragment, 1);
variance = var(fragment(:));
if variance == 0
filtered_fragment = fragment;
else
kernel_size = min(ceil(variance), fragment_size);
kernel = fspecial('gaussian', kernel_size, variance);
filtered_fragment = imfilter(fragment, kernel, 'conv');
end
end

----- END CODE: str289.m -----

----- START CODE: str290.m -----
% Код MATLAB для неперестраиваемого измерителя:

% Загрузка изображения
I = imread('tomo.jpg');

% Преобразование изображения в черно-белое
Igray = I;

% Определение порога для бинаризации
threshold = graythresh(Igray);

% Бинаризация изображения
Ibw = im2bw(Igray, threshold);

% Получение границ объекта
[B, L] = bwboundaries(Ibw, 'noholes');

% Определение координаты центра объекта
stats = regionprops('table', L, 'Centroid');
centroid = stats.Centroid(1,:);

% Построение графика с координатами объекта и его центра
figure;
imshow(I);
hold on;
plot(B{1}(:,2), B{1}(:,1), 'b', 'LineWidth', 1);
plot(centroid(1), centroid(2), 'ro', 'MarkerSize', 10, 'LineWidth', 2);
title('Обнаружение объекта и его центра');

% Сохранение координат центра объекта в переменную
object_center = centroid;

% Расчет площади объекта
object_area = stats.Area(1);

% Вывод площади объекта в командное окно
disp(['Площадь объекта: ', num2str(object_area)]);

% Сохранение бинаризованного изображения в переменную
binary_image = Ibw;

% Сравнение входного и бинаризованного изображений
figure;
subplot(1,2,1);
imshow(I);
title('Входное изображение');
subplot(1,2,2);
imshow(binary_image);
title('Бинаризованное изображение');

----- END CODE: str290.m -----

----- START CODE: str292_upd.m -----
% Чтение изображения
img = imread('tomo.jpg');

% Преобразование изображения в черно-белый формат
img_gray = img;

% Выделение границ объектов на изображении
edge_img = edge(img_gray, 'Canny');

% Заполнение внутренности объектов на изображении
fill_img = imfill(edge_img, 'holes');

% Получение меток для каждого объекта на изображении
label_img = bwlabel(fill_img);

% Извлечение свойств каждого объекта на изображении
props = regionprops(label_img);

% Вывод изображения с нарисованными контурами объектов
imshow(img);
hold on;
for i = 1:length(props)
    rectangle('Position', props(i).BoundingBox, 'EdgeColor', 'r', 'LineWidth', 2);
end
title('Обнаруженные объекты');
xlabel('Ширина, пиксели');
ylabel('Высота, пиксели');
hold off;

% Сохранение меток объектов в отдельную переменную
labels = label_img;

% Сохранение свойств объектов в отдельную переменную
objects = props;

% Вывод числа обнаруженных объектов на изображении
num_objects = length(props);
disp(['Обнаружено объектов: ', num2str(num_objects)]);

% График размеров объектов на изображении
sizes = [props.Area];
figure;
plot(sizes, 'bo');
title('Размеры объектов');
xlabel('Номер объекта');
ylabel('Площадь, пиксели');

% График описывающей прямоугольник сторон объектов
widths = [props.BoundingBox];
widths = widths(3:4:end);
heights = [props.BoundingBox];
heights = heights(4:4:end);
figure;
plot(widths, heights, 'ro');
title('Описывающий прямоугольник объектов');
xlabel('Ширина, пиксели');
ylabel('Высота, пиксели');

% Сохранение графиков в отдельные переменные
size_plot = gcf;
rect_plot = gcf;

----- END CODE: str292_upd.m -----

----- START CODE: str292_v2.m -----
% Цифровая обработка изображений 
% Оптимальная локализация и контуры изображений, выбор эталонных объектов


%% Загрузка и чтение изображения
img = imread('tomo.jpg'); % Загрузка изображения
img_gray = img; % Преобразование изображения в оттенки серого

%% Отображение изображения
figure;
imshow(img_gray); % Отображение исходного изображения

%% Применение фильтров для улучшения качества изображения
filtered_img = imsharpen(img_gray); % Применение улучшающего фильтра
bw_img = imbinarize(filtered_img, 'adaptive'); % Применение бинаризующего фильтра

%% Выделение контуров объектов
boundaries = bwboundaries(bw_img); % Получение координат контуров объектов

%% Отображение контуров
figure;
imshow(img);
hold on;

for i = 1:length(boundaries)
boundary = boundaries{i};
plot(boundary(:,2), boundary(:,1), 'g', 'LineWidth', 2);
end

hold off;

%% Сохранение результатов
imwrite(bw_img, 'output_image.jpg'); % Сохранение бинаризованного изображения

%% Вывод результатов
disp(['Найдено ' num2str(length(boundaries)) ' объектов']); % Вывод количества найденных объектов

%% Графики
figure;
subplot(1,2,1);
imshow(img_gray);
title('Исходное изображение');

subplot(1,2,2);
imshow(bw_img);
title('Бинаризованное изображение');

%% Подсчет площади найденных объектов
areas = zeros(length(boundaries), 1);

for i = 1:length(boundaries)
boundary = boundaries{i};
areas(i) = polyarea(boundary(:,2), boundary(:,1));
end

total_area = sum(areas);

%% Вывод результатов подсчета площади
disp(['Общая площадь найденных объектов: ' num2str(total_area)]);

%% Анализ эффективности кода
tic; % Начало отсчета времени выполнения скрипта

% Код скрипта

toc; % Окончание отсчета времени выполнения скрипта

----- END CODE: str292_v2.m -----

----- START CODE: str319_upd.m -----
% Загрузка изображения (пример: 'tomo.jpg')
nazvanie_izobrazheniya = 'tomo.jpg';
I = imread(nazvanie_izobrazheniya);

% Преобразование изображения в оттенки серого
% I_gray = rgb2gray(I);
I_gray = I;

% Применение контрастного масштабирования
% Задаем параметры: контрастный диапазон
kontrastnyi_diapazon = stretchlim(I_gray, [0.02 0.9]);

% Масштабирование изображения в контрастный диапазон
I_adjusted = imadjust(I_gray, kontrastnyi_diapazon, []);

% Сохранение результата
vykhodnye_dannye = I_adjusted;

% Отображение исходного изображения и обработанного изображения
figure;
subplot(1, 2, 1);
imshow(I_gray);
title('Исходное изображение');
subplot(1, 2, 2);
imshow(vykhodnye_dannye);
title('Коррекция контраста');

% Отображение гистограммы исходного изображения и обработанного изображения
figure;
subplot(1, 2, 1);
imhist(I_gray);
title('Гистограмма исходного изображения');
subplot(1, 2, 2);
imhist(vykhodnye_dannye);
title('Гистограмма обработанного изображения');

----- END CODE: str319_upd.m -----

----- START CODE: str325.m -----
% Создание MATLAB скрипта для видоизменения гистограмм изображений
% 12.2. Видоизменение гистограмм стр 325


% Загрузка изображения (измените путь к вашему изображению)
im = imread('tomo.jpg');
im = im; % Конвертирование изображения в оттенки серого

% Нормализация изображения
im_norm = double(im) / 255;

% Вычисление гистограммы изображения
[n, x] = hist(im_norm(:), 256);
n = n / sum(n); % Нормализация гистограммы

% Создание целевой гистограммы (равномерное распределение)
target_hist = ones(1, 256) / 256;

% Вычисление кумулятивной гистограммы
cum_hist = cumsum(n);
cum_target_hist = cumsum(target_hist);

% Инициализация отображения гистограммы
g = zeros(1, 256);

% Вычисление отображения гистограммы
for i = 1:256
[~, ind] = min(abs(cum_hist(i) - cum_target_hist));
g(i) = ind - 1;
end

% Применение отображения гистограммы к изображению
im_eq = uint8(reshape(g(im_norm(:) * 255 + 1), size(im)));

% Сохранение ключевых данных
im_ishod = im; % Исходное изображение
im_ravnom = im_eq; % Равномерно модифицированное изображение
g_ishod = cum_hist; % Кумулятивная гистограмма исходного изображения
g_ravnom = cum_target_hist; % Кумулятивная гистограмма равномерного распределения

% Графики сравнения входных и выходных данных
figure;

subplot(2, 2, 1);
imshow(im_ishod);
title('Исходное изображение');

subplot(2, 2, 2);
imshow(im_ravnom);
title('Равномерно модифицированное изображение');

subplot(2, 2, 3);
plot(g_ishod);
title('Кумулятивная гистограмма исходного изображения');
xlabel('Значение яркости');
ylabel('Кумулятивная частота');


----- END CODE: str325.m -----

----- START CODE: str492.m -----
% Цифровая обработка изображений
% Анализ изображений
% Яркостные признаки 17.1. Яркостные признаки

% Загрузка изображения
im = imread('tomo.jpg');
% Преобразование изображения в оттенки серого
im_gray = im;

% Размеры изображения
[rows, cols] = size(im_gray);

% Вычисление яркости
yarkost = mean(im_gray(:));

% Вычисление контраста
kontrast = std(double(im_gray(:)));

% Вычисление энтропии
im_p = imhist(im_gray) / numel(im_gray);
entropiya = -sum(im_p .* log2(im_p + (im_p==0)));

% Сохранение выходных данных
vyhod_yarkost = yarkost;
vyhod_kontrast = kontrast;
vyhod_entropiya = entropiya;

% График яркости и контраста
figure;
bar(1, vyhod_yarkost);
hold on;
bar(2, vyhod_kontrast);
hold off;
title('Сравнение яркости и контраста');
ylabel('Значение');
set(gca, 'XTickLabel', {'Яркость', 'Контраст'});
% Вычисление гистограммы изображения
im_hist = imhist(im_gray);

% Нормализация гистограммы
im_hist_normalized = im_hist / (rows * cols);

% Вычисление кумулятивной гистограммы
im_cum_hist = cumsum(im_hist_normalized);

% Применение эквализации гистограммы
im_eq = uint8(255 * im_cum_hist(im_gray + 1));

% Вычисление яркости, контраста и энтропии эквализированного изображения
yarkost_eq = mean(im_eq(:));
kontrast_eq = std(double(im_eq(:)));
im_p_eq = imhist(im_eq) / numel(im_eq);
entropiya_eq = -sum(im_p_eq .* log2(im_p_eq + (im_p_eq==0)));

% Сохранение выходных данных эквализированного изображения
vyhod_yarkost_eq = yarkost_eq;
vyhod_kontrast_eq = kontrast_eq;
vyhod_entropiya_eq = entropiya_eq;

% График сравнения яркости и контраста оригинального и эквализированного изображений
figure;
bar(1:2, [vyhod_yarkost, vyhod_kontrast], 'b');
hold on;
bar(3:4, [vyhod_yarkost_eq, vyhod_kontrast_eq], 'r');
hold off;
title('Сравнение яркости и контраста');
ylabel('Значение');
legend('Оригинальное изображение','Эквализированное изображение', 'Location', 'best');
set(gca, 'XTickLabel', {'Яркость', 'Контраст', 'Яркость (экв.)', 'Контраст (экв.)'});
grid on;

% График сравнения энтропии оригинального и эквализированного изображений
figure;
bar(1, vyhod_entropiya, 'b');
hold on;
bar(2, vyhod_entropiya_eq, 'r');
hold off;
title('Сравнение энтропии');
ylabel('Значение');
legend('Оригинальное изображение', 'Эквализированное изображение', 'Location', 'best');
set(gca, 'XTickLabel', {'Энтропия', 'Энтропия (экв.)'});
grid on;

% Визуализация оригинального и эквализированного изображений
figure;
subplot(1, 2, 1);
imshow(im_gray);
title('Оригинальное изображение');
subplot(1, 2, 2);
imshow(im_eq);
title('Эквализированное изображение');

% Визуализация гистограмм оригинального и эквализированного изображений
figure;
subplot(1, 2, 1);
bar(im_hist);
title('Гистограмма оригинального изображения');
xlabel('Интенсивность');
ylabel('Количество пикселей');
subplot(1, 2, 2);
bar(imhist(im_eq));
title('Гистограмма эквализированного изображения');
xlabel('Интенсивность');
ylabel('Количество пикселей');
grid on;

% График энтропии
figure;
bar(vyhod_entropiya);
title('Энтропия изображения');
ylabel('Значение');
set(gca, 'XTickLabel', {'Энтропия'});
grid on;

% 
% 4. К какой категории относится этот код?: Код относится к категории "Распознавание изображений".

----- END CODE: str492.m -----

----- START CODE: str493.m -----
% Скрипт для анализа изображений с использованием гистограммных и контурных признаков
% 17.2. Гистограммные признаки 
% 17.4. Контурные признаки




% Загрузка изображения
im = imread('tomo.jpg');
im_gray = im;

% Вычисление гистограммы
histogramma = imhist(im_gray);
normalizovannaya_histogramma = histogramma / numel(im_gray);

% Расчет контурных признаков
% Можно использовать оба порога для функции 'Canny'
krai = edge(im_gray, 'Canny', [0.001 0.002]); % Верхний и нижний пороги взяты как 0.1 и 0.2 для примера.

% Альтернатива: Если вы хотите использовать только один порог, вы можете закомментировать строку выше и раскомментировать строку ниже.
% krai = edge(im_gray, 'Canny', 0.1); % Здесь одно значение служит и нижним, и верхним порогом

% Вычисление ключевых характеристик гистограммы
srednee_znachenie = mean2(im_gray);
medianna = median(double(im_gray(:)));
otklonenie = std2(im_gray);
assimetriya = skewness(double(im_gray(:)));
eksczess = kurtosis(double(im_gray(:))) - 3;

% Вычисление ключевых характеристик контуров
kolichestvo_konturov = sum(krai(:));
konturnaya_ploshad = bwarea(krai);

% Сохранение результатов
rezultaty_gistogrammy = struct('histogramma', normalizovannaya_histogramma, 'srednee_znachenie', srednee_znachenie, 'medianna', medianna, 'otklonenie', otklonenie, 'assimetriya', assimetriya, 'eksczess', eksczess);
rezultaty_konturov = struct('kolichestvo_konturov', kolichestvo_konturov, 'konturnaya_ploshad', konturnaya_ploshad);

% Графики
figure;
subplot(2, 2, 1);
imshow(im);
title('Оригинальное изображение');

subplot(2, 2, 2);
imshow(im_gray);
title('Оттенки серого');

subplot(2, 2, 3);
bar(normalizovannaya_histogramma);
title('Нормализованная гистограмма');
xlabel('Уровни яркости');
ylabel('Частота');

subplot(2, 2, 4);
imshow(krai);
title('Контуры изображения');

----- END CODE: str493.m -----

----- START CODE: str702.m -----
% Создание примера изображения
A = imread('tomo.jpg');
% Преобразование изображения в полутоновое
polutonovoe_izobrazhenie = A;
% Преобразование полутонового изображения в двоичное изображение
binarnoe_izobrazhenie = imbinarize(polutonovoe_izobrazhenie);

% Создание структурного элемента для морфологической обработки
strelka = strel('disk', 2);

% Выполнение морфологической обработки
% Erosion
erosion = imerode(binarnoe_izobrazhenie, strelka);
% Dilation
dilation = imdilate(binarnoe_izobrazhenie, strelka);
% Opening
opening = imopen(binarnoe_izobrazhenie, strelka);
% Closing
closing = imclose(binarnoe_izobrazhenie, strelka);

% Вычисление границ изображения
granitsy = bwboundaries(binarnoe_izobrazhenie);

% Отображение результатов
subplot(2, 3, 1);
imshow(polutonovoe_izobrazhenie);
title('Полутоновое изображение');

subplot(2, 3, 2);
imshow(binarnoe_izobrazhenie);
title('Бинарное изображение');

subplot(2, 3, 3);
imshow(binarnoe_izobrazhenie);
title('Бинарное изображение после морфологической обработки');

subplot(2, 3, 4);
imshow(erosion);
title('Erosion');

subplot(2, 3, 5);
imshow(dilation);
title('Dilation');

subplot(2, 3, 6);
imshow(opening);
title('Opening');

subplot(2, 3, 6);
imshow(closing);
title('Closing');

figure;
% Отображение границ объектов на изображении
imshow(polutonovoe_izobrazhenie);
hold on;
for k = 1:length(granitsy)
boundary = granitsy{k};
plot(boundary(:,2), boundary(:,1), 'r', 'LineWidth', 2);
end
title('Границы объектов');

----- END CODE: str702.m -----

----- START CODE: str814.m -----
% MATLAB скрипт для сегментации изображений, обнаружения разрывов яркости и обнаружения точек

% Загрузка изображения (замените 'image.jpg' на имя вашего файла изображения)
izobrazhenie = imread('tomo.jpg');

% Преобразование изображения в оттенки серого
izobrazhenie_gray = izobrazhenie;

% Нормализация изображения
izobrazhenie_norm = double(izobrazhenie_gray) / 255;

% Вычисление градиента изображения
[grad_x, grad_y] = gradient(izobrazhenie_norm);

% Вычисление магнитуды и направления градиента
magnituda = sqrt(grad_x.^2 + grad_y.^2);
napravlenie = atan2(grad_y, grad_x);

% Устанавливаем порог для сегментации
porog = 0.3;

% Бинаризация изображения с использованием порога
binarizovannoe_izobrazhenie = imbinarize(magnituda, porog);

% Обнаружение разрывов яркости
razryvy_yarkosti = edge(izobrazhenie_gray, 'canny');

% Обнаружение точек
tochki = detectHarrisFeatures(izobrazhenie_gray);
% Отображение результатов
figure;
subplot(2,2,1);
imshow(izobrazhenie);
title('Оригинальное изображение');
subplot(2,2,2);
imshow(binarizovannoe_izobrazhenie);
title('Бинаризованное изображение');
subplot(2,2,3);
imshow(razryvy_yarkosti);
title('Обнаруженные разрывы яркости');
subplot(2,2,4);
imshow(izobrazhenie);
hold on;
plot(tochki.selectStrongest(50));
title('Обнаруженные точки Харриса');

----- END CODE: str814.m -----

----- START CODE: str831.m -----
% Создание скрипта MATLAB для сегментации изображений с использованием Лапласиана

% Загрузка изображения
im = imread('tomo.jpg');
im_gray = im;

% Преобразование изображения в тип double для дальнейших вычислений
im_gray = im2double(im_gray);

% Вычисление градиента изображения
[Gx, Gy] = gradient(im_gray);

% Вычисление второго порядка градиента (Лапласиан)
Lap = del2(im_gray);

% Устанавливаем пороговое значение
porog = 0.02;

% Находим перепады на основе порога
perepady = abs(Lap) > porog;

% Сохранение выходных данных в отдельную переменную
rezultat = perepady;

% Отображение изображений и графиков
figure;

% Входное изображение
subplot(2, 2, 1);
imshow(im_gray);
title('Исходное изображение');

% Градиент по X
subplot(2, 2, 2);
imshow(Gx, []);
title('Градиент по X');

% Градиент по Y
subplot(2, 2, 3);
imshow(Gy, []);
title('Градиент по Y');

% Результат сегментации
subplot(2, 2, 4);
imshow(rezultat);
title('Результат сегментации');

----- END CODE: str831.m -----

----- START CODE: str888.m -----
% Скрипт MATLAB для сегментации изображений с использованием алгоритма сегментации по водоразделам

% Загрузка изображения
im = imread('tomo.jpg');
im_gray = im;

% Преобразование изображения с использованием Гауссовой размытие
sigma = 2; % Стандартное отклонение для Гауссовой функции
im_blurred = imgaussfilt(im_gray, sigma);

% Вычисление градиента изображения
[grad_x, grad_y] = gradient(double(im_blurred));
grad_magnitude = sqrt(grad_x.^2 + grad_y.^2);

% Нормализация градиентов
grad_magnitude_norm = (grad_magnitude - min(grad_magnitude(:))) / (max(grad_magnitude(:)) - min(grad_magnitude(:)));

% Бинаризация изображения
binarization_threshold = 0.5;
binary_image = imbinarize(grad_magnitude_norm, binarization_threshold);

% Удаление шума с использованием морфологической операции
se = strel('disk', 2);
binary_image_clean = imopen(binary_image, se);

% Расстояние до ближайшей границы объекта
distance_map = bwdist(~binary_image_clean);

% Нормализация карты расстояний
distance_map_norm = (distance_map - min(distance_map(:))) / (max(distance_map(:)) - min(distance_map(:)));

% Метод кластеризации Watershed на основе карты расстояний

% Расширение карты расстояний
distance_map_ext = imhmax(distance_map_norm, 0.5);

% Вычисление водоразделов
watershed_labels = watershed(-distance_map_ext);

% Нанесение водоразделов на исходное изображение
overlay = imoverlay(im, watershed_labels == 0, [1 0 0]);

% Визуализация результатов
figure;
subplot(2,2,1);
imshow(im);
title('Исходное изображение');
subplot(2,2,2);
imshow(binary_image_clean);
title('Бинаризованное изображение');
subplot(2,2,3);
imshow(distance_map_norm);
title('Нормализованная карта расстояний');
subplot(2,2,4);
imshow(overlay);
title('Результат сегментации по водоразделам');


figure;
subplot(1,2,1);
histogram(binary_image_clean(:));
title('Гистограмма binary_image_clean');
subplot(1,2,2);
histogram(distance_map_norm(:));
title('Гистограмма distance_map_norm');




----- END CODE: str888.m -----

----- START CODE: str888_upd.m -----
% Загрузка изображения
im = imread('tomo.jpg');
im_gray = im;

% Преобразование изображения с использованием Гауссовой размытие
sigma = 2; % Стандартное отклонение для Гауссовой функции
im_blurred = imgaussfilt(im_gray, sigma);

% Вычисление градиента изображения
[grad_x, grad_y] = gradient(double(im_blurred));
grad_magnitude = sqrt(grad_x.^2 + grad_y.^2);

% Нормализация градиентов
grad_magnitude_norm = (grad_magnitude - min(grad_magnitude(:))) / (max(grad_magnitude(:)) - min(grad_magnitude(:)));
disp(['Min, Max и Mean значения нормализованных градиентов: ', num2str(min(grad_magnitude_norm(:))), ', ', num2str(max(grad_magnitude_norm(:))), ', ', num2str(mean(grad_magnitude_norm(:)))])

% Бинаризация изображения
binarization_threshold = 0.5;
binary_image = imbinarize(grad_magnitude_norm, binarization_threshold);
disp(['Процент пикселей, превышающих порог бинаризации: ', num2str(100*mean(binary_image(:))), '%'])

% Удаление шума с использованием морфологической операции
se = strel('disk', 2);
binary_image_clean = imopen(binary_image, se);

% Расстояние до ближайшей границы объекта
distance_map = bwdist(~binary_image_clean);

% Нормализация карты расстояний
distance_map_norm = (distance_map - min(distance_map(:))) / (max(distance_map(:)) - min(distance_map(:)));
disp(['Min, Max и Mean значения нормализованных расстояний: ', num2str(min(distance_map_norm(:))), ', ', num2str(max(distance_map_norm(:))), ', ', num2str(mean(distance_map_norm(:)))])

% Метод кластеризации Watershed на основе карты расстояний

% Расширение карты расстояний
distance_map_ext = imhmax(distance_map_norm, 0.5);

% Вычисление водоразделов
watershed_labels = watershed(-distance_map_ext);
disp(['Число найденных регионов водораздела: ', num2str(max(watershed_labels(:)))])

----- END CODE: str888_upd.m -----

----- START CODE: str942.m -----
% стр 942

% Создание скрипта MATLAB для анализа связных компонент в сегментированном изображении
% и выделение максимально крупных признаков.

% Загрузка изображения (пример)
I = imread('tomo.jpg'); % Замените 'your_image_file.jpg' на имя вашего файла изображения

% Преобразование в полутоновое изображение
I_gray = I;

% Сегментация изображения с использованием порога
threshold = graythresh(I_gray);
I_bin = imbinarize(I_gray, threshold);

% Подсчет связных компонент
[labels, num] = bwlabel(I_bin);

% Вычисление свойств связных компонент
properties = regionprops(labels, 'Area', 'BoundingBox', 'Centroid');

% Отбор максимально крупных признаков
max_area = max([properties.Area]);
max_area_components = find([properties.Area] == max_area);

% Вывод изображений и результатов
figure;

% Исходное изображение
subplot(2, 2, 1);
imshow(I);
title('Исходное изображение');

% Сегментированное изображение
subplot(2, 2, 2);
imshow(I_bin);
title('Сегментированное изображение');

% Отображение максимально крупных признаков над связных компонент на исходном изображении
subplot(2, 2, 3);
imshow(I);
hold on;
for i = 1:length(max_area_components)
idx = max_area_components(i);
rectangle('Position', properties(idx).BoundingBox, 'EdgeColor', 'r', 'LineWidth', 2);
plot(properties(idx).Centroid(1), properties(idx).Centroid(2), 'r*', 'LineWidth', 2);
end
title('Максимально крупные признаки');

% Вывод результатов анализа
subplot(2, 2, 4);
disp(['Количество связных компонент: ', num2str(num)]);
disp(['Максимальная площадь: ', num2str(max_area)]);
disp(['Количество максимально крупных признаков: ', num2str(length(max_area_components))]);
title('Результаты анализа');

----- END CODE: str942.m -----

----- START CODE: str969_v1.m -----
A = imread('tomo.jpg');
rezultat = analyze_image(A);


function rezultat = analyze_image(A)

% Размер изображения
razmer = size(A);

% Бинаризация изображения
porog = 0.5;
binar = imbinarize(A, porog);

% Определение границ и областей объекта
[Gx, Gy] = imgradientxy(binar, 'Sobel');
G = sqrt(Gx.^2 + Gy.^2);
oblast = imfill(G, 'holes');
granitsa = G > 0;

% Вычисление координат пикселей объекта и границы
[oblastY, oblastX] = find(oblast);
[granitsaY, granitsaX] = find(granitsa);

% Создание двумерных векторов
oblastVektor = [oblastX, oblastY];
granitsaVektor = [granitsaX, granitsaY];

% Вычисление вектора математического ожидания и ковариационной матрицы
sredneeOblast = mean(oblastVektor);
kovMatOblast = cov(oblastVektor);
sredneeGranitsa = mean(granitsaVektor);
kovMatGranitsa = cov(granitsaVektor);

% Графики
figure;

subplot(2, 2, 1);
imshow(A);
title('Оригинальное изображение');

subplot(2, 2, 2);
imshow(binar);
title('Бинаризованное изображение');

subplot(2, 2, 3);
imshow(oblast);
hold on;
plot(sredneeOblast(1), sredneeOblast(2), 'r+', 'MarkerSize', 10);
title('Область объекта с центром масс');

subplot(2, 2, 4);
imshow(granitsa);
hold on;
plot(sredneeGranitsa(1), sredneeGranitsa(2), 'r+', 'MarkerSize', 10);
title('Граница объекта с центром масс');

% Сохранение ключевых данных
rezultat.binar = binar;
rezultat.oblast = oblast;
rezultat.granitsa = granitsa;
rezultat.sredneeOblast = sredneeOblast;
rezultat.kovMatOblast = kovMatOblast;
rezultat.sredneeGranitsa = sredneeGranitsa;
rezultat.kovMatGranitsa = kovMatGranitsa;

end

----- END CODE: str969_v1.m -----

----- START CODE: str969_v1_dermo.m -----
% Загрузка изображения
izobrazhenie = imread('tomo.jpg'); % Замените 'put_izobrazheniya.jpg' на путь к вашему изображению
gray_izobrazhenie = izobrazhenie;

% Бинаризация изображения
bin_izobrazhenie = imbinarize(gray_izobrazhenie);

% Определение границ изображения с настраиваемым порогом
porog = [0.01, 0.02]; % Задание нижнего и верхнего порогов для метода Canny
granitsy = edge(bin_izobrazhenie, 'Canny', porog);


% Выделение контуров
[contury, ~] = bwboundaries(granitsy, 'noholes');

% Построение двумерных векторов координат границы
vektory_granits = cell(length(contury), 1);

for i = 1:length(contury)
    vektory_granits{i} = [contury{i}(:, 2), contury{i}(:, 1)];
end

% Применение PCA для сжатия данных и определения главных компонент
glavnye_komponenty = cell(length(contury), 1);

for i = 1:length(contury)
    [koef, score] = pca(vektory_granits{i});
    if size(score, 2) >= 2
        glavnye_komponenty{i} = score(:, 1:2);
    else
        glavnye_komponenty{i} = score(:, 1);
    end
end

% Сохранение выходных данных
vykhodnye_dannye = glavnye_komponenty;

% Отображение входных и выходных данных
figure;
subplot(1, 2, 1);
imshow(izobrazhenie);
title('Исходное изображение');

subplot(1, 2, 2);
imshow(granitsy);
title('Границы изображения');
hold on;

% Отображение главных компонент на границах
for i = 1:length(contury)
    if size(glavnye_komponenty{i}, 2) >= 2
        plot(glavnye_komponenty{i}(:, 1), glavnye_komponenty{i}(:, 2), 'r', 'LineWidth', 2);
    else
        plot(glavnye_komponenty{i}(:, 1), glavnye_komponenty{i}(:, 1), 'r', 'LineWidth', 2);
end
end

title('Главные компоненты границы');
hold off;



----- END CODE: str969_v1_dermo.m -----

----- START CODE: str969_v2.m -----
% Чтение изображения из файла
imyaFayla = 'tomo.jpg'; % Замените на путь к вашему изображению
A = imread(imyaFayla);

% Преобразование изображения в оттенки серого
if size(A, 3) == 3
    A = rgb2gray(A);
end

% Нормализация изображения
A = im2double(A);

% Бинаризация изображения
porog = 0.5;
binar = imbinarize(A, porog);

% Определение границ и областей объекта
[Gx, Gy] = imgradientxy(binar, 'Sobel');
G = sqrt(Gx.^2 + Gy.^2);
oblast = imfill(G, 'holes');

% Вычисление координат пикселей объекта
[oblastY, oblastX] = find(oblast);

% Создание двумерных векторов
oblastVektor = [oblastX, oblastY];

% Вычисление вектора математического ожидания и ковариационной матрицы
sredneeOblast =mean(oblastVektor);
kovMatOblast = cov(oblastVektor);

% Выполнение метода главных компонент (PCA)
[V, D] = eig(kovMatOblast);

% Расчет конечных точек для визуализации направления
tsentr = sredneeOblast;
konec1 = tsentr + V(:,1)' * 50; % Множитель для масштабирования длины вектора
nachalo1 = tsentr - V(:,1)' * 50;
konec2 = tsentr + V(:,2)' * 50;
nachalo2 = tsentr - V(:,2)' * 50;

% Графики
figure;

subplot(1, 2, 1);
imshow(A);
title('Исходное изображение');

subplot(1, 2, 2);
imshow(oblast);
hold on;
plot(tsentr(1), tsentr(2), 'r+', 'MarkerSize', 10);
plot([nachalo1(1), konec1(1)], [nachalo1(2), konec1(2)], 'r-', 'LineWidth', 2);
plot([nachalo2(1), konec2(1)], [nachalo2(2), konec2(2)], 'g-', 'LineWidth', 2);
title('Область объекта с направлениями главных компонент');


% Сохранение ключевых данных
rezultat.binar = binar;
rezultat.oblast = oblast;
rezultat.sredneeOblast = sredneeOblast;
rezultat.kovMatOblast = kovMatOblast;
rezultat.napravlenie1 = V(:,1);
rezultat.napravlenie2 = V(:,2);


----- END CODE: str969_v2.m -----

